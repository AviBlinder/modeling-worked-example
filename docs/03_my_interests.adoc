= Recommendations by explicit interest
:csv-url: https://raw.githubusercontent.com/neo4j-meetups/modeling-worked-example/master/data/
:icons: font

== Member Interests (Topics)

What data do we have?
Run the following query to find out:

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS
FROM "{csv-url}members.csv" AS row
RETURN row.id, row.topics
LIMIT 10
----

Note that we're still processing the same members file as we were earlier but returning different columns this time.

So we've got one column containing the member id and one with a `;` delimited set of topic ids.
Our next task is to create a relationship between members and their topics.
To do that we're going to need to split up the string containing topic ids so we can process them one at a time.

We'll use link:http://neo4j.com/docs/new-manual/developer-manual/3.0-RC1/#functions-split[split] and link:http://neo4j.com/docs/new-manual/developer-manual/3.0-RC1/#query-plan-unwind[UNWIND] to help us do this.

ifdef::env-training[]

== The slides are waiting...for you!

image::{img}/slides.jpg[]

endif::env-training[]

== Member Interests (Topics)

Run the following query to create an `INTERESTED_IN` relationship between members and topics:

[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS FROM "{csv-url}members.csv" AS row

WITH split(row.topics, ";") AS topics, row.id AS memberId
UNWIND topics AS topicId

WITH DISTINCT memberId, topicId
MATCH (member:Member {id: memberId})
MATCH (topic:Topic {id: topicId})
MERGE (member)-[:INTERESTED_IN]->(topic)
----

This might take a bit of time - there's a lot of members and topics to get through!

== Find my similar groups

Now we're ready to write our first query which uses some data we've explicitly provided meetup.

[source,cypher]
----
MATCH (member:Member {name: "Mark Needham"})-[:INTERESTED_IN]->(topic),
      (member)-[:MEMBER_OF]->(group)-[:HAS_TOPIC]->(topic)
WITH member, topic, COUNT(*) AS score
MATCH (topic)<-[:HAS_TOPIC]-(otherGroup)
WHERE NOT (member)-[:MEMBER_OF]->(otherGroup)
RETURN otherGroup.name, COLLECT(topic.name), SUM(score) as score
ORDER BY score DESC
----

In this query we

  * start from me
  * find the topics I'm interested in
  * find the groups I'm a member of that have those topics
  * aggregates the number of times each topic appears
  * finds other groups that have these topics, filtering out ones that I'm already a member of
  * returns those other groups sorted by how many of my topics they cater for

This is quite a crude scoring mechanism which favours generally popular topics.
We'll have a look at how to address that later on.

== What if I don't specify any interests?

My friend Aleks didn't specify any interests when he signed up for meetup...

[source,cypher]
----
MATCH (member:Member {name: "Aleksander Sumowski"})-[:INTERESTED_IN]->(topic), (member)-[:MEMBER_OF]->(group)-[:HAS_TOPIC]->(topic)
WITH member, topic, COUNT(*) AS score
MATCH (topic)<-[:HAS_TOPIC]-(otherGroup)
WHERE NOT (member)-[:MEMBER_OF]->(otherGroup)
RETURN otherGroup.name, COLLECT(topic.name), SUM(score) as score
ORDER BY score DESC
----

... so we can't make any recommendations to him.
Sad times!

However, if he's a member of some groups we can infer his interests.

== What am I actually interested in?

The `INTERESTED_IN` relationships that we created are based on interests that a user declared when they signed up for meetup.com.
People typically don't change those as their interests change but they do join new groups frequently which allows us to know their interests better than they do!

We can do this by inferring `INTERESTED_IN` relationships based on these groups.

image::{img}/group_has_topic_member_of.png[]

ifdef::env-training[]

== Exercise: Inferring interests

* Find topics that I'm interested in via the groups I'm a member of that I don't have an `INTERESTED_IN` relationship to.
* Which topic shows up most frequently?

== The answers are waiting...

image::{img}/slides.jpg[]

endif::env-training[]

== Persisting inferred interests

We can write the following query to add inferred `INTERESTED_IN` relationships to each member:

[source,cypher]
----
MATCH (m:Member)-[:MEMBER_OF]->()-[:HAS_TOPIC]->(topic)
WHERE NOT (m)-[:INTERESTED_IN]->(topic)

WITH m, topic, COUNT(*) AS times
WHERE times >= 3

MERGE (m)-[:INTERESTED_IN]->(topic)
----

The query:

* goes over each member
* finds the groups they're a member of and which topics those groups advertise
* counts how many times each topic has showed up
* removes any topics that show up less than 3 times
* creates an `INTERESTED_IN` relationship between the member and the remaining topics

On this dataset we have a sufficiently small number of members that we can process them all in one go.
With a production sized dataset we'd need to process members in batches.

== Find my similar groups (even if I don't know it yet)

So we're still answering the same fundamental question as before...

[verse]
____
As a member of several meetup groups
I want to find other similar meetup groups that Iâ€™m not already a member of
So that I can join those groups
____

...but now we've added in some extra relationships which allow us to make recommendations even to people like Aleks who haven't specified any interests.

Run the following query:

[source,cypher]
----
MATCH (member:Member {name: "Aleksander Sumowski"})-[:INTERESTED_IN]->(topic),
      (member)-[:MEMBER_OF]->(group)-[:HAS_TOPIC]->(topic)
WITH member, topic, COUNT(*) AS score
MATCH (topic)<-[:HAS_TOPIC]-(otherGroup)
WHERE NOT (member)-[:MEMBER_OF]->(otherGroup)
RETURN otherGroup.name, COLLECT(topic.name), SUM(score) as score
ORDER BY score DESC
----

== What about collaborative filtering?

The queries we've written so far all detect similarity of groups based on content which in this case means topics that they have in common.
Another way we can detect similarity is by using collaborative filtering where we ignore content completely and show the other groups that people in our groups joined.

The following query does this:

[source,cypher]
----
MATCH (member:Member {name: "Mark Needham"})-[:MEMBER_OF]->()<-[:MEMBER_OF]-(other:Member)
WITH DISTINCT member, other
MATCH (other)-[:MEMBER_OF]->(otherGroup:Group)
WHERE NOT((member)-[:MEMBER_OF]->(otherGroup))
WITH otherGroup, COUNT(*) AS times
MATCH (otherGroup)<-[:MEMBER_OF]-()
RETURN otherGroup.name, times, COUNT(*) AS members
ORDER BY times DESC
----

Apparently we should all be joining the `FREE Marketing, Analytics & Digital Skills in London` group.
Try changing the name and see if you can find someone who doesn't see that group on their list!

== A hybrid approach

We might even choose to combine those two queries into a hybrid query that uses content based and collaborative filtering together.

[source,cypher]
----

----

== Next Step

We're now reached the end of the group recommendation section of the training.
In the next section we're going to explore the events hosted by our groups and then make event recommendations.

pass:a[<a play-topic='{guides}/04_events.html'>Event Recommendations</a>]
