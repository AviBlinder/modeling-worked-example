= Recommendations by explicit interest
:csv-url: https://raw.githubusercontent.com/neo4j-meetups/modeling-worked-example/master/data/
:icons: font

== Member Interests (Topics)

What data do we have?
Run the following query to find out:

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS
FROM "{csv-url}members.csv" AS row
RETURN row.id, row.topics
LIMIT 10
----

Note that we're still processing the same members file as we were earlier but returning different columns this time.

So we've got one column containing the member id and one with a `;` delimited set of topic ids.
Our next task is to create a relationship between members and their topics.
To do that we're going to need to split up the string containing topic ids so we can process them one at a time.

We'll use link:http://neo4j.com/docs/new-manual/developer-manual/3.0-RC1/#functions-split[split] and link:http://neo4j.com/docs/new-manual/developer-manual/3.0-RC1/#query-plan-unwind[UNWIND] to help us do this.

ifdef::env-training[]

== The slides are waiting...for you!

image::{img}/slides.jpg[]

endif::env-training[]

== Member Interests (Topics)

Run the following query to create an `INTERESTED_IN` relationship between members and topics:

[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS FROM "{csv-url}members.csv" AS row

WITH split(row.topics, ";") AS topics, row.id AS memberId
UNWIND topics AS topicId

WITH DISTINCT memberId, topicId
MATCH (member:Member {id: memberId})
MATCH (topic:Topic {id: topicId})
MERGE (member)-[:INTERESTED_IN]->(topic)
----

This might take a bit of time - there's a lot of members and topics to get through!

== Find my similar groups

Now we're ready to write our first query centered around a person instead of a group.

[source,cypher,subs=attributes]
----
MATCH (member:Member {name: "Mark Needham"})-[:INTERESTED_IN]->(topic),
      (member)-[:MEMBER_OF]->(group)-[:HAS_TOPIC]->(topic)
WITH member, topic, COUNT(*) AS score
MATCH (topic)<-[:HAS_TOPIC]-(otherGroup)
WHERE NOT (member)-[:MEMBER_OF]->(otherGroup)
RETURN otherGroup.name, COLLECT(topic.name), SUM(score) as score
ORDER BY score DESC
----

In this query we

  * start from me
  * find the topics I'm interested in
  * find the groups I'm a member of that have those topics
  * aggregates the number of times each topic appears
  * finds other groups that have these topics, filtering out ones that I'm already a member of
  * returns those other groups sorted by how many of my topics they cater for

This is quite a crude scoring mechanism which favours generally popular topics.
Let's account for that.

// TODO *SOMETHING HERE WITH BETTER SCORING TO DOWNPLAY REALLY POPULAR TOPICS*

== What am I actually interested in?

The `INTERESTED_IN` relationships that we created are based on interests that a user declared when they signed up for meetup.com.
People typically don't change those as their interests change but they do join new groups frequently which allows us to know their interests better than they do!

We can do this by inferring `INTERESTED_IN` relationships based on these groups.

image::{img}/group_has_topic_member_of.png[]

ifdef::env-training[]


== Exercise: Inferring interests

* Find topics that I'm interested in via the groups I'm a member of that I don't have an `INTERESTED_IN` relationship to.
* Which topic shows up most frequently?

== The answers are waiting...

image::{img}/slides.jpg[]

endif::env-training[]

== Inferring interests

We can write the following query to add inferred `INTERESTED_IN` relationships to each member:

[source,cypher,subs=attributes]
----
MATCH (m:Member)-[:MEMBER_OF]->()-[:HAS_TOPIC]->(topic)

WITH m, topic, COUNT(*) AS times
WHERE times >= 5

MERGE (m)-[:INTERESTED_IN]->(topic)
----

The query:

* goes over each member
* finds the groups they're a member of and which topics those groups advertise
* counts how many times each topic has showed up
* removes any topics that show up less than 5 times
* creates an `INTERESTED_IN` relationship between the member and the remaining topics

On this dataset we have a sufficiently small number of members that we can process them all in one go.
With a production sized dataset we'd need to process members in batches.

== Find my similar groups (even if I don't know it yet)

So we're still answering the same fundamental question as before...

[verse]
____
As a member of several meetup groups
I want to find other similar meetup groups that Iâ€™m not already a member of
So that I can join those groups
____

...but now we've added in some extra relationships which will hopefully lead to a better recommendation.

Let's see how the results of our group recommendation query change:

[source,cypher,subs=attributes]
----
MATCH (member:Member {name: "Mark Needham"})-[:INTERESTED_IN]->(topic),
      (member)-[:MEMBER_OF]->(group)-[:HAS_TOPIC]->(topic)
WITH member, topic, COUNT(*) AS score
MATCH (topic)<-[:HAS_TOPIC]-(otherGroup)
WHERE NOT (member)-[:MEMBER_OF]->(otherGroup)
RETURN otherGroup.name, COLLECT(topic.name), SUM(score) as score
ORDER BY score DESC
----

== Next Step

We're now reached the end of the group recommendation section of the training.
In the next section we're going to explore the events hosted by our groups and then make event recommendations.

pass:a[<a play-topic='{guides}/04_events.html'>Event Recommendations</a>]
