= Layered Events
:csv-url: https://raw.githubusercontent.com/neo4j-meetups/modeling-worked-example/master/data/
:icons: font

== Combine Multiple Scores into a Layered Query

Here we are going to build a hybrid recommendation engine that takes lots of factors into account.

WARN: Let's create some scoring functions in APOC so we can use those inside queries.

Anyway this is what we have to start with:

* events in my groups
* events I’ve previously attended
* topics I’m interested in
* events my peers attend

== Events I previously attended

[verse]
____
As a member of several meetup  groups who has previously  attended events
I want to find other events hosted by those groups
So that I can attend those events
____

== Import RSVPs to Events

=== Look at the Data

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS FROM "{csv-url}rsvps.csv" AS row
RETURN row  LIMIT 10
----

=== Run the Import

[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS FROM "{csv-url}rsvps.csv" AS row
WITH row WHERE row.response = "yes"
MATCH (member:Member {id: row.member_id})
MATCH (event:Event {id: row.event_id})
MERGE (member)-[rsvp:RSVPD {id: row.rsvp_id}]->(event)
ON CREATE SET rsvp.created = toInt(row.created),  
              rsvp.lastModified = toInt(row.mtime),  
              rsvp.response = row.response;
----

== Previous events attended

[source,cypher]
----
WITH 24.0*60*60*1000 AS oneDay

MATCH (member:Member {name: "Mark Needham"}) 
MATCH (futureEvent:Event) WHERE futureEvent.time >= timestamp() 
MATCH (futureEvent)<-[:HOSTED_EVENT]-(group)  

WITH oneDay, group, futureEvent, member, EXISTS((group)<-[:MEMBER_OF]-(member)) AS isMember

OPTIONAL MATCH (member)-[rsvp:RSVPD]->(pastEvent)<-[:HOSTED_EVENT]-(group) 
WHERE pastEvent.time < timestamp()

RETURN group.name, futureEvent.name, isMember, 
       COUNT(rsvp) AS previousEvents, 
       round((futureEvent.time - timestamp()) / oneDay) AS days
ORDER BY days, previousEvents DESC
----

== My topics

[source,cypher,subs=attributes]
----
WITH 24.0*60*60*1000 AS oneDay 

MATCH (member:Member {name: "Mark Needham"}) 
MATCH (futureEvent:Event) WHERE futureEvent.time >= timestamp()
MATCH (futureEvent)<-[:HOSTED_EVENT]-(group)

WITH oneDay, group, futureEvent, member, EXISTS((group)<-[:MEMBER_OF]-(member)) AS isMember

OPTIONAL MATCH (member)-[rsvp:RSVPD]->(pastEvent)<-[:HOSTED_EVENT]-(group) 
WHERE pastEvent.time < timestamp()  

WITH oneDay, group, futureEvent, member, isMember, 
     COUNT(rsvp) AS previousEvents

OPTIONAL MATCH (futureEvent)<-[:HOSTED_EVENT]-()-[:HAS_TOPIC]->(topic)<-[:INTERESTED_IN]-(member)  

RETURN group.name, futureEvent.name, isMember, 
       previousEvents, 
       COUNT(topic) AS topics, 
       round((futureEvent.time - timestamp()) / oneDay) AS days
ORDER BY days,previousEvents DESC, topics DESC
----

== Find the social graph lurking within

I have no idea how long this takes to run - had it using a Python script in the talk
Perhaps this is another candidate for procedures?

[source,cypher,subs=attributes]
----
MATCH (m1:Member) WHERE size( (m1)-[:RSVPD]->() ) >= 5
MATCH (m1)-[:RSVPD]->(event:Event)<-[:RSVPD]-(m2:Member) WHERE size( (m2)-[:RSVPD]->() ) >= 5
WITH m1, m2, COLLECT(event) AS events, COUNT(*) AS times
WHERE times >= 5
WITH m1, m2, times, [event IN events | SIZE((event)<-[:RSVPD]-())] AS attendances
WITH m1, m2, REDUCE(score = 0.0, a IN attendances | score + (1.0 / a)) AS score

MERGE (m1)-[friendsRel:FRIENDS]-(m2)
ON CREATE SET friendsRel.score = score
----

== Events my friends are attending

[source,cypher,subs=attributes]
----
WITH 24.0*60*60*1000 AS oneDay
MATCH (member:Member {name: "Mark Needham"})
MATCH (futureEvent:Event) WHERE futureEvent.time >= timestamp()
MATCH (futureEvent)<-[:HOSTED_EVENT]-(group)

WITH oneDay, group, futureEvent, member, EXISTS((group)<-[:MEMBER_OF]-(member)) AS isMember
OPTIONAL MATCH (member)-[rsvp:RSVPD {response: "yes"}]->(pastEvent)<-[:HOSTED_EVENT]-(group)
WHERE pastEvent.time < timestamp()

WITH oneDay, group, futureEvent, member, isMember, COUNT(rsvp) AS previousEvents
OPTIONAL MATCH (futureEvent)<-[:HOSTED_EVENT]-()-[:HAS_TOPIC]->(topic)<-[:INTERESTED_IN]-(member)

WITH oneDay, group, futureEvent, member, isMember, previousEvents, COUNT(topic) AS topics
OPTIONAL MATCH (member)-[:FRIENDS]-(:Member)-[rsvpYes:RSVP_YES]->(futureEvent)

RETURN group.name, futureEvent.name, isMember, 
       round((futureEvent.time - timestamp()) / oneDay) AS days, 
       previousEvents, topics, 
       COUNT(rsvpYes) AS friendsGoing
ORDER BY days, friendsGoing DESC, previousEvents DESC
LIMIT 15
----

== Next Step

For high performance recommendations we can use Neo4j Stored Procedures to run some more demanding algorithms on our data.

pass:a[<a play-topic='{guides}/06_procedures.html'>Using Neo4j Procedures for Recommendations</a>]
