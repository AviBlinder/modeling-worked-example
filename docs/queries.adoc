= Groups similar to Neo4j

[source, cypher]
----
MATCH (group:Group {name: "Neo4j - London User Group"})-[:HAS_TOPIC]->(topic)<-[:HAS_TOPIC]-(otherGroup)
RETURN otherGroup.name,
       COUNT(topic) AS topicsInCommon,
       COLLECT(topic.name) AS topics
ORDER BY topicsInCommon DESC
LIMIT 10
----

= Groups similar to Neo4j that I'm not already a member of

[source, cypher]
----
MATCH (group:Group {name: "Neo4j - London User Group"})-[:HAS_TOPIC]->(topic)<-[:HAS_TOPIC]-(otherGroup:Group)
WHERE NOT (:Member {name: "Mark Needham"})-[:MEMBER_OF]->(otherGroup)
RETURN otherGroup.name,
       COUNT(topic) AS topicsInCommon,
       COLLECT(topic.name) AS topics
ORDER BY topicsInCommon DESC
LIMIT 10
----

= Groups similar to the ones I'm already a member of

[source, cypher]
----
MATCH (member:Member {name: "Mark Needham"})-[:INTERESTED_IN]->(topic), (member)-[:MEMBER_OF]->(group)-[:HAS_TOPIC]->(topic)
WITH member, topic, COUNT(*) AS score
MATCH (topic)<-[:HAS_TOPIC]-(otherGroup)
RETURN otherGroup.name, EXISTS((member)-[:MEMBER_OF]->(otherGroup)) AS alreadyMember,
       COLLECT(topic.name),
       SUM(score) as score
ORDER BY score DESC
----

= Groups similar to the ones I'm already a member of that I'm not already a member of

[source, cypher]
----
MATCH (member:Member {name: "Mark Needham"})-[:INTERESTED_IN]->(topic),
      (member)-[:MEMBER_OF]->(group)-[:HAS_TOPIC]->(topic)
WITH member, topic, COUNT(*) AS score
MATCH (topic)<-[:HAS_TOPIC]-(otherGroup)
WHERE NOT (member)-[:MEMBER_OF]->(otherGroup)
RETURN otherGroup.name,
       COLLECT(topic.name),
       SUM(score) as score
ORDER BY score DESC
----

= Groups similar to the ones I'm already a member of that I'm not already a member of ignoring my espoused interests

[source, cypher]
----
MATCH (member:Member {name: "Mark Needham"})-[:MEMBER_OF]->(group)-[:HAS_TOPIC]->(topic)
WITH member, topic, COUNT(*) AS score
MATCH (topic)<-[:HAS_TOPIC]-(otherGroup)
WHERE NOT (member)-[:MEMBER_OF]->(otherGroup)
RETURN otherGroup.name,
       COLLECT(topic.name),
       SUM(score) as score
ORDER BY score DESC
----

= Next group that people join

[source, cypher]
----
MATCH (group:Group {name: "Neo4j - London User Group"})<-[membership:MEMBER_OF]-(member),
      (member)-[otherMembership:MEMBER_OF]->(otherGroup)
WHERE membership.joined < otherMembership.joined
WITH member, otherGroup
ORDER BY otherMembership.joined
WITH member, COLLECT(otherGroup)[0] AS nextGroup
RETURN nextGroup.name,
       COUNT(*) AS times
ORDER BY times DESC
----

= Next group that people join with explicit membership

[source, cypher]
----
MATCH (group:Group {name: "Neo4j - London User Group"})<-[:OF_GROUP]-(membership)-[:NEXT]->(nextMembership),
      (membership)<-[:HAS_MEMBERSHIP]-(member:Member)-[:HAS_MEMBERSHIP]->(nextMembership),
      (nextMembership)-[:OF_GROUP]->(nextGroup)
RETURN nextGroup.name, COUNT(*) AS times
ORDER BY times DESC
----

= Events to attend in the next 2 weeks

[source, cypher]
----
MATCH (member:Member {name: "Mark Needham"})-[:RSVPD {response: "yes"}]->(event:Event)<-[:RSVPD {response: "yes"}]-(otherMember:Member)
WHERE (timestamp() - 30*24*60*60*1000) <= event.time < timestamp()

WITH DISTINCT member, otherMember
MATCH (otherMember)-[:RSVPD {response: "yes"}]->(other:Event)<-[:HOSTED_EVENT]-(group)
WHERE timestamp() <= other.time < (timestamp() + (14*24*60*60*1000))
AND NOT ((member)-[:RSVPD]->(other))
RETURN group.name,
       other.name, COUNT(otherMember) AS times,
       COLLECT(otherMember.name) AS people,
       (other.time - timestamp()) / 1000 / 60 / 60 / 24.0 AS days
ORDER BY times DESC
----

= Finding common events

[source, cypher]
----
MATCH (member:Member {name: "Mark Needham"})-[:RSVPD {response: "yes"}]->(event:Event)<-[:RSVPD {response: "yes"}]-(otherMember:Member)
WHERE (timestamp() - 30*24*60*60*1000) <= event.time < timestamp()

WITH member, otherMember, COLLECT(event.name) AS commonEvents
MATCH (otherMember)-[:RSVPD {response: "yes"}]->(other:Event)<-[:HOSTED_EVENT]-(group)
WHERE other.time > timestamp() AND NOT ((member)-[:RSVPD]->(other))

WITH group, other, COUNT(otherMember) AS times,
     COLLECT({other: otherMember.name, events: commonEvents}) AS people
RETURN group.name,
       other.name,
       COLLECT(people) AS people,
       times,
       (other.time - timestamp()) / 1000 / 60 / 60 / 24.0 AS days
ORDER BY times DESC
----


Layered event recommendation

* Events for groups I'm a member of
* Events for topics I'm interested in
* Events for indirect topics that I'm interested in
* Events that my peers go to
