= Similar groups
:csv-url: https://raw.githubusercontent.com/neo4j-meetups/modeling-worked-example/master/data/
:icons: font

== Find similar groups to Neo4j

image::{img}/group_has_topic.png[float=right]

[verse]
____
As a member of the Neo4j London group
I want to find other similar meetup groups
So that I can join those groups
____

== What makes groups similar?

One thing that makes groups similar is the topics that they’re about.

[verse]
____
As a member of the Neo4j London group
I want to find other similar meetup groups
So that I can join those groups
____

ifndef::env-guide[]

== Groups

----
|-----------+------------------------------+----------------------------+--------+----------------|
|  id       | name                         | urlname                    | rating | created        |
|-----------+------------------------------+----------------------------+--------+----------------|
|  841735   | LJC - London Java Community  | Londonjavacommunity        | 4.54   | 1196081014000  |
|  18313232 | Kubernetes London            | Kubernetes-London          | 5      | 1420729836000  |
|  18581527 | data+visual London           | data-visual-London         | 4.67   | 1431021679000  |
|  163876   | London Web                   | londonweb                  | 4.11   | 1034097743000  |
|  15734842 | Ansible London               | Ansible-London             | 4.42   | 1405439359000  |
|  12963902 | Scalability London           | Scalability-London         | 4.95   | 1392824462000  |
|  4062902  | Ember London                 | London-Emberjs-User-Group  | 4.66   | 1339522219000  |
|  14354522 | London PaaS & Bluemix Meetup | London-PaaS-Bluemix-Meetup | 5      | 1399643167000  |
|-----------+------------------------------+----------------------------+--------+----------------|
----

endif::[]

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS
FROM "{csv-url}groups.csv"
AS row
RETURN row
LIMIT 10
----

== Import Groups

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS
FROM "{csv-url}groups.csv"
AS row
CREATE (:Group { id:row.id,
                 name:row.name,
                 urlname:row.urlname,
                 rating:toint(row.rating),
                 created:toint(row.created) })
----

We use CREATE because we know the database is empty when we start.

[source,cypher,subs=attributes]
----
MATCH (g:Group)
RETURN g.id, g.name, g.urlname
----

Topics express areas of interest for both groups and members.

ifndef::env-guide[]

----
|----------+---------------------------+--------------------------|
|  id      | name                      | urlkey                   |
|----------+---------------------------|--------------------------|
|  827     | .NET                      | dotnet                   |
|  2109    | System Administration     | sysadmin                 |
|  2260    | C#                        | csharp                   |
|  10105   | Microsoft Windows         | mswindows                |
|  15167   | Cloud Computing           | cloud-computing          |
|  46810   | Configuration Management  | configuration-management |
|  52210   | PowerShell                | powershell               |
|  66339   | Windows Azure Platform    | windows-azure-platform   |
|  84706   | Scripting                 | scripting                |
|  87614   | DevOps                    | devops                   |
|  99537   | Microsoft Technology      | microsoft-technology     |
|  160268  | Windows                   | windows                  |
|  189     | Java                      | java                     |
|  563     | Open Source               | opensource               |
|----------+---------------------------+--------------------------|
----

endif::[]

== Detour: MERGE & Constraints

We want to use `MERGE` because we want to avoid creating duplicate topics
Make sure to have a unique constraint on `:Topic(id)` so we don’t create the same topic twice.

We create unique constraints to:

* ensure uniqueness
* allow fast lookup of nodes which match these (label,property) pairs.
* it does the latter by creating an index on the (label, property) pair

[source,cypher,subs=attributes]
----
CREATE CONSTRAINT ON (t:Topic) ASSERT t.id IS UNIQUE
----

[source,cypher,subs=attributes]
----
CREATE CONSTRAINT ON (g:Group) ASSERT g.id IS UNIQUE
----

== Import Topics

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS FROM "{csv-url}groups_topics.csv"  AS row
MERGE (topic:Topic {id: row.id})
ON CREATE SET topic.name = row.name,
              topic.urlkey = row.urlkey
----

=== Find Topics

[source,cypher,subs=attributes]
----
MATCH (t:Topic)
RETURN t.id, t.name
----

ifndef::env-guide[]
== Group Topics

----
|----------+-----------|
|  id      | groupId   |
|----------+-----------|
|  827     | 18780165  |
|  2109    | 18780165  |
|  2260    | 18780165  |
|  10105   | 18780165  |
|  15167   | 18780165  |
|  46810   | 18780165  |
|  46831   | 18780165  |
|  52210   | 18780165  |
|----------+-----------|
----
endif::[]

== Connect groups and topics

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS FROM "{csv-url}groups_topics.csv"  AS row
MATCH (topic:Topic {id: row.id})
MATCH (group:Group {id: row.groupId})
MERGE (group)-[:HAS_TOPIC]->(topic)
----

The use of `MERGE` here ensures that we end up with a single unique link between a group and a topic.

If we run the query a second time nothing will happen.
If we run another `MERGE` query that tries to create a `:HAS_TOPIC` relationship when one already exists it won’t do anything.

== Additional Indexes

We create an index on `:Group(name)` so that we can quickly look up groups by name.

[source,cypher,subs=attributes]
----
CREATE INDEX ON :Group(name)
----

Same for topics.

[source,cypher,subs=attributes]
----
CREATE INDEX ON :Topic(name)
----

==  Find similar groups to Neo4j

[source,cypher,subs=attributes]
----
MATCH (group:Group {name: "Neo4j - London User Group"})-[:HAS_TOPIC]->(topic)<-[:HAS_TOPIC]-(otherGroup)
RETURN otherGroup.name, COUNT(topic) AS topicsInCommon,
       COLLECT(topic.name) AS topics
ORDER BY topicsInCommon DESC, otherGroup.name
LIMIT 10
----

Now that we’ve got the data in let’s see if our model is any good.

This query

* starts from the Neo4j group,
* finds its topics,
* then looks for other groups that have that topic
* and aggregates the groups with the most common topics.
