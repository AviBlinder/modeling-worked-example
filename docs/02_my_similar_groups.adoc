= Recommendations by implicit interest
:csv-url: https://raw.githubusercontent.com/neo4j-meetups/modeling-worked-example/master/data/
:icons: font

== Exclude groups I’m a member of

Finding groups similar to the Neo4j group is a decent start but most good recommendation engines try to make recommendations customised for the user.

Although our first query was a good one to get us started, unfortunately it was suggesting that we join groups that we might already be a member of.
The worst type of recommendation!

In this section we're going to add membership data to our model to fix that.

image::{img}/group_has_topic_member_of.png[]

[verse]
____
As a member of the Neo4j London group
I want to find other similar meetup groups that I’m not already a member of
So that I can join those groups
____

== Explore Members data

Let's see what data we've got to play with.
Run the following query to show the first ten rows of the members CSV file:

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS
FROM "{csv-url}members.csv" AS row
RETURN row
LIMIT 10
----

This file contains members for all the groups that we imported in the previous section.

== Add Members

Now we'll put those members into our database.

We first create a unique constraint on `Member(id)` to ensure we don't insert the same member twice.

[source,cypher,subs=attributes]
----
CREATE CONSTRAINT ON (m:Member)
ASSERT m.id IS UNIQUE
----

We'll also put an index on `Member(name)` so we can quickly look up a given member.

[source,cypher,subs=attributes]
----
CREATE INDEX ON :Member(name)
----

And finally let's load the members.

Note that we're using periodic commit here.
In this example it means that we'll commit every 10,000 rows rather than processing the whole file in one large transaction.

[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS
FROM "{csv-url}members.csv" AS row
WITH DISTINCT row.id AS id, row.name AS name
MERGE (member:Member {id: id})
ON CREATE SET member.name = name
----

== Add Membership

Now that we've got the members imported, the next step is to get them connected to the groups that we loaded in the first section.

[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS
FROM "{csv-url}members.csv" AS row
WITH row WHERE NOT row.joined is null
MATCH (member:Member {id: row.id})
MATCH (group:Group {id: row.groupId})
MERGE (member)-[membership:MEMBER_OF]->(group)
ON CREATE SET membership.joined=toInt(row.joined);
----

== Exercise: Find yourself and your groups

We've now got groups, topics and members loaded into our database so it's time for a bit more exploration.

* If you're from London write a query to find yourself in the database. If not try and find your neighbour.
* How many groups are you a member of?
* Which topics do those groups have?
* _(For bonus points)_ Which topic shows up the most?

== Exclude groups I’m a member of

For our next recommendation we're still going to be finding similar groups to the Neo4j one but we'll also check whether we're already a member of the other groups.

[source,cypher,subs=attributes]
----
MATCH (group:Group {name: "Neo4j - London User Group"})-[:HAS_TOPIC]->(topic)<-[:HAS_TOPIC]-(otherGroup:Group)
RETURN otherGroup.name,
       COUNT(topic) AS topicsInCommon,
       EXISTS((:Member {name: "Mark Needham"})-[:MEMBER_OF]->(otherGroup)) AS alreadyMember,
       COLLECT(topic.name) AS topics
ORDER BY topicsInCommon DESC
LIMIT 10
----

So now we identify them as being ones we’re already a member of so there’s no point in recommending them again.

An interesting thing to notice is that we now get back groups which we didn’t before.
That’s because we didn’t force any ordering other than `topicsInCommon` so we won't get a repeatable order on other columns.

Try changing the member name to your name or your neighbours and see how the results change.

* INSERT SOME OTHER NAMES THAT PEOPLE CAN TRY HERE *

== Exclude groups I’m a member of

In the following query we move the exclusion pattern up into a `WHERE` clause so groups we're already a member of won't be returned at all.

[source,cypher,subs=attributes]
----
MATCH (group:Group {name: "Neo4j - London User Group"})-[:HAS_TOPIC]->(topic)<-[:HAS_TOPIC]-(otherGroup:Group)
WHERE NOT( (:Member {name: "Mark Needham"})-[:MEMBER_OF]->(otherGroup) )
RETURN otherGroup.name,
       COUNT(topic) AS topicsInCommon,
       COLLECT(topic.name) AS topics
ORDER BY topicsInCommon DESC
LIMIT 10
----

Try changing the names of the group and member to see how the results vary.

== Find my similar groups

Now we’re going to make our recommendation on an individual basis.

image::{img}/group_has_topic_member_of_interested_in.png[]

[verse]
____
As a member of several meetup groups
I want to find other similar meetup groups that I’m not already a member of
So that I can join those groups
____

We can use collaborative filtering to see what other groups people in our groups join.

A classic case of *closing the triangle.*
We have two sides, let’s close the third side.

If I join groups which have a specific topic more frequently then we can weight in that ones favour.

== Next Step

Looking at our interests we can determine new interesting groups as well as infer new interests based on my membership and attendance.

pass:a[<a play-topic='{guides}/03_my_interests.html'>My Interests</a>]
