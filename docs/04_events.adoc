= Events
:csv-url: https://raw.githubusercontent.com/neo4j-meetups/modeling-worked-example/master/data/
:icons: font

== Import Events

Now it’s time to bring events into the graph.

[source,cypher,subs=attributes]
----
CREATE INDEX ON :Event(id)
----

[source,cypher,subs=attributes]
----
CREATE INDEX ON :Event(time)
----

[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS FROM "{csv-url}events.csv" AS row
MERGE (event:Event {id: row.id})
ON CREATE SET event.name = row.name,
              event.time = toInt(row.time),
              event.utcOffset = toInt(row.utc_offset)
----


[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS FROM "{csv-url}events.csv" AS row
WITH distinct row.group_id as groupId, row.id as eventId
MATCH (group:Group {id: groupId})
MATCH (event:Event {id: eventId})
MERGE (group)-[:HOSTED_EVENT]->(event)
----

== Find future events in my groups

Once we start looking to make event recommendations the simplest thing we can do is find the groups we’re a member of and then find its future events

[source,cypher,subs=attributes]
----
WITH 24.0*60*60*1000 AS oneDay

MATCH (member:Member {name: "Mark Needham"})
MATCH (futureEvent:Event) WHERE futureEvent.time >= timestamp()
MATCH (futureEvent)<-[:HOSTED_EVENT]-(group)

RETURN group.name,
       futureEvent.name,
       EXISTS((group)<-[:MEMBER_OF]-(member)) AS isMember,
       round((futureEvent.time - timestamp()) / oneDay) AS days
ORDER BY isMember DESC, days
----

== Next Step

A real world recommendation consists of several scores.
Let us explore how we can build up a scoring query step by step to recommend future events to attend.

pass:a[<a play-topic='{guides}/05_layered_events.html'>Layered Event Recommendations</a>]