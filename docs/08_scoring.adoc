= Scoring recommendations
:csv-url: https://raw.githubusercontent.com/neo4j-meetups/modeling-worked-example/master/data/
:icons: font

== Scoring components of our recommendation query

We're now at the point where we now have multiple facets to our events recommendation query.
Each of these makes a contribution but perhaps not all equally.

e.g. perhaps we should give more weight to venues closer to our workplace and less weight to very popular events.


Here we are going to build a hybrid recommendation engine that takes lots of factors into account.

WARN: Let's create some scoring functions in APOC so we can use those inside queries.

Anyway this is what we have to start with:

* events in my groups
* events I’ve previously attended
* topics I’m interested in
* events my peers attend

== Events I previously attended

[verse]
____
As a member of several meetup  groups who has previously  attended events
I want to find other events hosted by those groups
So that I can attend those events
____

== Import RSVPs to Events

=== Look at the Data

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS FROM "{csv-url}rsvps.csv" AS row
RETURN row  LIMIT 10
----

=== Run the Import

[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS FROM "{csv-url}rsvps.csv" AS row
WITH row WHERE row.response = "yes"
MATCH (member:Member {id: row.member_id})
MATCH (event:Event {id: row.event_id})
MERGE (member)-[rsvp:RSVPD {id: row.rsvp_id}]->(event)
ON CREATE SET rsvp.created = toInt(row.created),
              rsvp.lastModified = toInt(row.mtime),
              rsvp.response = row.response;
----

== Previous events attended

[source,cypher]
----
WITH 24.0*60*60*1000 AS oneDay

MATCH (member:Member {name: "Mark Needham"})
MATCH (futureEvent:Event) WHERE futureEvent.time >= timestamp()
MATCH (futureEvent)<-[:HOSTED_EVENT]-(group)

WITH oneDay, group, futureEvent, member, EXISTS((group)<-[:MEMBER_OF]-(member)) AS isMember

OPTIONAL MATCH (member)-[rsvp:RSVPD]->(pastEvent)<-[:HOSTED_EVENT]-(group)
WHERE pastEvent.time < timestamp()

RETURN group.name, futureEvent.name, isMember,
       COUNT(rsvp) AS previousEvents,
       round((futureEvent.time - timestamp()) / oneDay) AS days
ORDER BY days, previousEvents DESC
----

== My topics

[source,cypher,subs=attributes]
----
WITH 24.0*60*60*1000 AS oneDay

MATCH (member:Member {name: "Mark Needham"})
MATCH (futureEvent:Event) WHERE futureEvent.time >= timestamp()
MATCH (futureEvent)<-[:HOSTED_EVENT]-(group)

WITH oneDay, group, futureEvent, member, EXISTS((group)<-[:MEMBER_OF]-(member)) AS isMember

OPTIONAL MATCH (member)-[rsvp:RSVPD]->(pastEvent)<-[:HOSTED_EVENT]-(group)
WHERE pastEvent.time < timestamp()

WITH oneDay, group, futureEvent, member, isMember,
     COUNT(rsvp) AS previousEvents

OPTIONAL MATCH (futureEvent)<-[:HOSTED_EVENT]-()-[:HAS_TOPIC]->(topic)<-[:INTERESTED_IN]-(member)

RETURN group.name, futureEvent.name, isMember,
       previousEvents,
       COUNT(topic) AS topics,
       round((futureEvent.time - timestamp()) / oneDay) AS days
ORDER BY days,previousEvents DESC, topics DESC
----

== Find the social graph lurking within

The social graph is a common feature of a lot of modern web applications.
Typically that social graph is imported from a 3rd party system e.g. Twitter followers or Facebook friends.

In this dataset there is actually a latent social graph hiding beneath the data we've looked at so far.
RSVPs give us a reasonable idea of which people may know each other based on common meetups they've attended.

We can write the following query to see which people on the meetup scene that I may know:

[source,cypher,subs=attributes]
----
MATCH (me:Member {name: "Mark Needham"})-[:RSVPD]->()<-[:RSVPD]-(otherPerson)
RETURN otherPerson, COUNT(*) AS commonEvents
ORDER BY commonEvents DESC
----

== Codifying the latent social graph

We'll have to run a graph global query to codify this social network so we're going to use one of the `apoc` procedures to help us out.



[source,cypher,subs=attributes]
----
MATCH (m1:Member) WHERE size( (m1)-[:RSVPD]->() ) >= 5
MATCH (m1)-[:RSVPD]->(event:Event)<-[:RSVPD]-(m2:Member) WHERE size( (m2)-[:RSVPD]->() ) >= 5
WITH m1, m2, COLLECT(event) AS events, COUNT(*) AS times
WHERE times >= 5
WITH m1, m2, times, [event IN events | SIZE((event)<-[:RSVPD]-())] AS attendances
WITH m1, m2, REDUCE(score = 0.0, a IN attendances | score + (1.0 / a)) AS score

MERGE (m1)-[friendsRel:FRIENDS]-(m2)
ON CREATE SET friendsRel.score = score
----

== Events my friends are attending

[source,cypher,subs=attributes]
----
WITH 24.0*60*60*1000 AS oneDay
MATCH (member:Member {name: "Mark Needham"})
MATCH (futureEvent:Event) WHERE futureEvent.time >= timestamp()
MATCH (futureEvent)<-[:HOSTED_EVENT]-(group)

WITH oneDay, group, futureEvent, member, EXISTS((group)<-[:MEMBER_OF]-(member)) AS isMember
OPTIONAL MATCH (member)-[rsvp:RSVPD {response: "yes"}]->(pastEvent)<-[:HOSTED_EVENT]-(group)
WHERE pastEvent.time < timestamp()

WITH oneDay, group, futureEvent, member, isMember, COUNT(rsvp) AS previousEvents
OPTIONAL MATCH (futureEvent)<-[:HOSTED_EVENT]-()-[:HAS_TOPIC]->(topic)<-[:INTERESTED_IN]-(member)

WITH oneDay, group, futureEvent, member, isMember, previousEvents, COUNT(topic) AS topics
OPTIONAL MATCH (member)-[:FRIENDS]-(:Member)-[rsvpYes:RSVP_YES]->(futureEvent)

RETURN group.name, futureEvent.name, isMember,
       round((futureEvent.time - timestamp()) / oneDay) AS days,
       previousEvents, topics,
       COUNT(rsvpYes) AS friendsGoing
ORDER BY days, friendsGoing DESC, previousEvents DESC
LIMIT 15
----

== Next Step

By now you probably have lots of ideas of how we can improve the graph to make even better recommendations.
In this last session you'll have the chance to explore some of this solo or in a team with other attendees.

pass:a[<a play-topic='{guides}/09_free_for_all.html'>Your turn</a>]
