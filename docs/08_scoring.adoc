= Scoring recommendations
:csv-url: https://raw.githubusercontent.com/neo4j-meetups/modeling-worked-example/master/data/
:icons: font

ifdef::env-training[]

== Scoring components of our recommendation query

We're now at the point where we have multiple facets to our events recommendation query.
Each of these makes a contribution but perhaps not all equally.

e.g. perhaps we should give more weight to venues closer to our workplace and less weight to very popular events.


== The pareto function

The pareto function in `apoc` allows us to apply a log function to a score.
We want to dampen the weight of really high scores so they don't completely dominate the recommendation.

Let's give it a try on some fake data to get the hang of it:

[source,cypher, subs=attributes]
----
CALL apoc.scoring.pareto(1,2,3,4)
----

The parameters might seem a bit opaque at the moment but you can learn more about them by running the following query:

[source, cypher, subs=attributes]
----
CALL db.procedures() YIELD name AS name, signature AS signature
WITH name, signature
WHERE name = "apoc.scoring.pareto"
RETURN signature
----

Try changing some of the values and see how the score changes.

== Scoring with Pareto

Now let's try applying the Pareto function to the event recommendation query.


[source, cypher, subs=attributes]
----


----

endif::env-training[]

== Layered Event Scoring

Here we are going to build a hybrid recommendation engine that takes lots of factors into account.

// WARN: Let's create some scoring functions in APOC so we can use those inside queries.

Anyway this is what we have to start with:

* events in my groups
* events I’ve previously attended
* topics I’m interested in
* events my peers attend

== Events I previously attended

[verse]
____
As a member of several meetup  groups who has previously  attended events
I want to find other events hosted by those groups
So that I can attend those events
____

////

We already have this.
== Import RSVPs to Events

=== Look at the Data

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS FROM "{csv-url}rsvps.csv" AS row
RETURN row  LIMIT 10
----

=== Run the Import

[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS FROM "{csv-url}rsvps.csv" AS row
WITH row WHERE row.response = "yes"
MATCH (member:Member {id: row.member_id})
MATCH (event:Event {id: row.event_id})
MERGE (member)-[rsvp:RSVPD {id: row.rsvp_id}]->(event)
ON CREATE SET rsvp.created = toInt(row.created),
              rsvp.lastModified = toInt(row.mtime),
              rsvp.response = row.response;
----

////

== Previous events attended

[source,cypher]
----
WITH 24.0*60*60*1000 AS oneDay

MATCH (member:Member {name: "Mark Needham"})
MATCH (futureEvent:Event) WHERE futureEvent.time >= timestamp()
MATCH (futureEvent)<-[:HOSTED_EVENT]-(group)

WITH oneDay, group, futureEvent, member, EXISTS((group)<-[:MEMBER_OF]-(member)) AS isMember

OPTIONAL MATCH (member)-[rsvp:RSVPD]->(pastEvent)<-[:HOSTED_EVENT]-(group)
WHERE pastEvent.time < timestamp()

RETURN group.name, futureEvent.name, isMember,
       COUNT(rsvp) AS previousEvents,
       round((futureEvent.time - timestamp()) / oneDay) AS days
ORDER BY days, previousEvents DESC
----

== My topics

[source,cypher,subs=attributes]
----
WITH 24.0*60*60*1000 AS oneDay

MATCH (member:Member {name: "Mark Needham"})
MATCH (futureEvent:Event) WHERE futureEvent.time >= timestamp()
MATCH (futureEvent)<-[:HOSTED_EVENT]-(group)

WITH oneDay, group, futureEvent, member, EXISTS((group)<-[:MEMBER_OF]-(member)) AS isMember

OPTIONAL MATCH (member)-[rsvp:RSVPD]->(pastEvent)<-[:HOSTED_EVENT]-(group)
WHERE pastEvent.time < timestamp()

WITH oneDay, group, futureEvent, member, isMember,
     COUNT(rsvp) AS previousEvents

OPTIONAL MATCH (futureEvent)<-[:HOSTED_EVENT]-()-[:HAS_TOPIC]->(topic)<-[:INTERESTED_IN]-(member)

RETURN group.name, futureEvent.name, isMember,
       previousEvents,
       COUNT(topic) AS topics,
       round((futureEvent.time - timestamp()) / oneDay) AS days
ORDER BY days,previousEvents DESC, topics DESC
----

== Find the social graph lurking within

The social graph is a common feature of a lot of modern web applications.
Typically that social graph is imported from a 3rd party system e.g. Twitter followers or Facebook friends.

In this dataset there is actually a latent social graph hiding beneath the data we've looked at so far.
RSVPs give us a reasonable idea of which people may know each other based on common meetups they've attended.

We can write the following query to see which people on the meetup scene that I may know:

[source,cypher,subs=attributes]
----
MATCH (me:Member {name: "Mark Needham"})-[:RSVPD]->()<-[:RSVPD]-(otherPerson)
RETURN otherPerson, COUNT(*) AS commonEvents
ORDER BY commonEvents DESC
LIMIT 10
----


== Codifying the latent social graph

We'll have to run a graph global query to materialize this inferred social network so we're going to batch with a `Processed` label in a few steps.

First apply that label to active members of our meetups.

[source,cypher,subs=attributes]
----
MATCH (m:Member) WHERE size( (m)-[:RSVPD]->() ) >= 5
SET m:Process
RETURN count(*)
----

Then run the query we've seen before for each batch of 1000 at a time, result in up to 100000 relationships to be created.


[source,cypher,subs=attributes]
----
MATCH (m1:Process) WITH m1 LIMIT 1000
REMOVE m1:Process
WITH m1
MATCH (m1)-[:RSVPD]->(event)<-[:RSVPD]-(m2) WHERE size( (event)<-[:RSVPD]-() ) >= 5 AND size( (m2)-[:RSVPD]->() ) >= 5

WITH m1, m2, COUNT(*) AS times
WHERE times >= 5

MERGE (m1)-[:FRIENDS]-(m2)
RETURN count(*);
----

In total we created that 300 000 `FRIENDS` relationships.

[source,cypher,subs=attributes]
----
match ()-[:FRIENDS]-() RETURN COUNT(*)
----


////
== Codifying the latent social graph

We'll have to run a graph global query to materialize this inferred social network so we're going to use one of the `apoc` procedures to help us out.

Export active meetup attendees to $NEO4J_HOME/import/active.csv

[source,cypher,subs=attributes]
----
MATCH (m:Member) WHERE size( (m)-[:RSVPD]->() ) >= 5
RETURN m.id as id
----

[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 100
LOAD CSV WITH HEADERS FROM "{csv-url}active.csv" AS row
MATCH (m1:Member) WHERE m1.id = row.id
MATCH (m1)-[:RSVPD]->(event:Event)<-[:RSVPD]-(m2:Member) WHERE size( (m2)-[:RSVPD]->() ) >= 5
WITH m1, m2,  COUNT(*) AS times
WHERE times >= 5
WITH m1, m2, times

MERGE (m1)-[friendsRel:FRIENDS]-(m2)
ON CREATE SET friendsRel.score = times;
----

////
////
== Codifying the latent social graph

We'll have to run a graph global query to materialize this inferred social network so we're going to use one of the `apoc` procedures to help us out.


[source,cypher,subs=attributes]
----
MATCH (m:Member) WHERE size( (m)-[:RSVPD]->() ) >= 5
SET m:Process
RETURN count(*)
----

[source,cypher,subs=attributes]
----
MATCH (m1:Process) WITH m1 LIMIT 1000

MATCH (m1)-[:RSVPD]->(event)<-[:RSVPD]-(m2) WHERE size( (event)<-[:RSVPD]-() ) >= 5 AND size( (m2)-[:RSVPD]->() ) >= 5

WITH m1, m2, COUNT(*) AS times
WHERE times >= 5

MERGE (m1)-[friendsRel:FRIENDS]-(m2)
REMOVE m1:Process
RETURN count(*);
----

[source,cypher,subs=attributes]
----
MATCH (m1:Member) WHERE size( (m1)-[:RSVPD]->() ) >= 5
MATCH (m1)-[:RSVPD]->(event:Event)<-[:RSVPD]-(m2:Member) WHERE size( (event)<-[:RSVPD]-() ) >= 5  AND size( (m2)-[:RSVPD]->() ) >= 5
WITH m1, m2, COLLECT(event) AS events, COUNT(*) AS times
WHERE times >= 5
WITH m1, m2, times, [event IN events | SIZE((event)<-[:RSVPD]-())] AS attendances
WITH m1, m2, REDUCE(score = 0.0, a IN attendances | score + (1.0 / a)) AS score

MERGE (m1)-[friendsRel:FRIENDS]-(m2)
----

////


== Events my friends are attending

[source,cypher,subs=attributes]
----
WITH 24.0*60*60*1000 AS oneDay
MATCH (member:Member {name: "Mark Needham"})
MATCH (futureEvent:Event) WHERE futureEvent.time >= timestamp()
MATCH (futureEvent)<-[:HOSTED_EVENT]-(group)

WITH oneDay, group, futureEvent, member, EXISTS((group)<-[:MEMBER_OF]-(member)) AS isMember
OPTIONAL MATCH (member)-[rsvp:RSVPD]->(pastEvent)<-[:HOSTED_EVENT]-(group)
WHERE pastEvent.time < timestamp()

WITH oneDay, group, futureEvent, member, isMember, COUNT(rsvp) AS previousEvents
OPTIONAL MATCH (futureEvent)<-[:HOSTED_EVENT]-()-[:HAS_TOPIC]->(topic)<-[:INTERESTED_IN]-(member)

WITH oneDay, group, futureEvent, member, isMember, previousEvents, COUNT(topic) AS topics
OPTIONAL MATCH (member)-[:FRIENDS]-(:Member)-[rsvpFriend:RSVPD]->(futureEvent)

RETURN group.name, futureEvent.name, isMember,
       round((futureEvent.time - timestamp()) / oneDay) AS days,
       previousEvents, topics,
       COUNT(rsvpFriend) AS friendsGoing
ORDER BY days, friendsGoing DESC, previousEvents DESC
LIMIT 15
----

== Next Step

By now you probably have lots of ideas of how we can improve the graph to make even better recommendations.
In this last session you'll have the chance to explore some of this solo or in a team with other attendees.

pass:a[<a play-topic='{guides}/09_free_for_all.html'>Your turn</a>]
